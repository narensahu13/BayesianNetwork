install.packages("abind")
install.packages("arrayhelpers")
library(arrayhelpers)
shiny::runApp()
Sales <- array(NA, c(max(x$Store), max(x$Dept), max(x$Year)))
structure(list(Store = c(35L, 35L, 35L, 35L, 35L), Dept = c(71L,
71L, 71L, 71L, 71L), Year = c(1, 2, 3, 4, 5), Sales = c(10908.04,
12279.99, 11061.82, 12288.1, 9950.55)), .Names = c("Store", "Dept",
"Year", "Sales"), row.names = c(NA, -5L), class = "data.frame")
x<- structure(list(Store = c(35L, 35L, 35L, 35L, 35L), Dept = c(71L,
71L, 71L, 71L, 71L), Year = c(1, 2, 3, 4, 5), Sales = c(10908.04,
12279.99, 11061.82, 12288.1, 9950.55)), .Names = c("Store", "Dept",
"Year", "Sales"), row.names = c(NA, -5L), class = "data.frame")
Sales <- array(NA, c(max(x$Store), max(x$Dept), max(x$Year)))
Sales
for (i in 1:nrow(x))
Sales[x[i,"Store"], x[i,"Dept"], x[i,"Year"]] <- x[i, "Sales"]
Sales[35,71,1]
for (i in 1:nrow(x))
Sales[x[i,"Store"], x[i,"Dept"], x[i,"Year"]] <- x[i, "Sales"]
Sales
xtabs(Sales ~ Store + Dept + Year, x)
my_array <- array(1:600, dim=c(10,5,12))
my_matrix<-data.frame()
for (j in 1:5) {
for (i in 1:10) {
my_matrix <- rbind (my_matrix, my_array[i,j,1:12])
}
}
my_array
my_matrix
res <- matrix(my_array, prod(dim(my_array)[1:2]), dim(my_array)[3])
all.equal(as.matrix(my_matrix), res, check.attributes=FALSE)
matrix(my_array, 10*5, 12)
nchar("matrix(my_array, 10*5, 12)")
install.packages("narray")
library(narray)
my_array
flatten(my_array)
bind(my_array)
array2df(my_array)
array2df
my_array <- array(1:60, dim=c(5,3,2,2))
my_array
my_array <- array(1:60, dim=c(5,3,2,2)dimnames = c('col1','col2','col3','col4'))
my_array <- array(1:60, dim=c(5,3,2,2),dimnames = c('col1','col2','col3','col4'))
my_array <- array(1:60, dim=c(5,3,2,2),dimnames = list('col1','col2','col3','col4'))
my_array <- array(1:60, dim=c(5,3,2,2),dimnames = list(c('col1','col2','col3','col4')))
?array
list('x1','x2','x3')
my_array <- array(1:60, dim=c(5,3,2,2),dimnames = list('col1','col2','col3','col4'))
length(list('x1','x2','x3'))
my_array <- array(1:60, dim=c(5,3,2,2),dimnames = list(c('A','B','C','D','E'),c('a','b','c'),c('a1','a2'),c('b1','b2')))
my_array
my_array[[1]]
my_array[[1,1]]
my_array[1,2]
my_array[1]
my_array[2]
my_array[20]
names(my_array)
dimnames(my_array)
dimnames(my_array)[1]
dimnames(my_array)[2]
getwd()
load('Fraudmodel.RData')
network
runApp()
source('~/BayesianNetwork/Fraudmodel.R', echo=TRUE)
network[["Impact"]]$CPT
source('~/BayesianNetwork/Fraudmodel.R', echo=TRUE)
network[["Impact"]]$CPT
dimnames(network[["Impact"]]$CPT)
dimnames(network[["Impact"]]$CPT)[1]
names(dimnames(network[["Impact"]]$CPT)[1])
values(dimnames(network[["Impact"]]$CPT)[1])
CPT <- network[["Impact"]]$CPT
CPT
dim(CPT)
dims <- dim(CPT)
n_dims <- length(dims)
child_states <- dimnames(CPT)[[1]]
parent_states_1 <- dimnames(CPT)[[2]]
parent_states_2 <- dimnames(CPT)[[3]]
child_states
parent_states_1
parent_states_2
dimnames(CPT)[[4]]
names(child_states)
names(CPT)
dimnames(CPT)
dimnames(CPT)[1]
dimnames(CPT)[[1[]]
dimnames(CPT)[[1]]
dimnames(CPT)[[2]]
dimnames(CPT)[[1]]
dimnames(CPT)[1]
dimnames(CPT)[1][1]
child_states
dimnames(CPT)[1][1]
dimnames(CPT)[1]
dimnames(dimnames(CPT)[1])
names(dimnames(CPT)[1])
dims
child_states
dims(child_states)
dims
dims[1]
n_dims
matrix_dim <- c(dims[1]+n_dims-1, dims[2]*dims[3]*dims[4]+1)
matrix_dim
df <- data.frame(matrix(NA, nrow = matrix_dim[1], ncol = matrix_dim[2]))
df
df <- data.frame(matrix(NA, nrow = matrix_dim[1], ncol = matrix_dim[2]), row.names = NULL)
df
df <- data.frame(matrix(NA, nrow = matrix_dim[1], ncol = matrix_dim[2], dimnames = NULL))
df
df[1,1]
df[1,]
df[,1]
child_name <- names(dimnames(CPT)[1])
parent_name1 <- names(dimnames(CPT)[2])
parent_name2 <- names(dimnames(CPT)[3])
parent_name3 <- names(dimnames(CPT)[4])
df[,1] <- c(parent_name1,parent_name2,parent_name3,child_states)
df
child_states
df[1,2:]
df[1,2::]
df[1,]
df[1,-1]
parent_states_1
dim(parent_states_1)
prod(dims)
dims
prod(dims[-1])
df[1,-1] <- rep(parent_states_1,prod(dims[-1])/dims[1])
parent_states_1
prod(dims[-1])/dims[1]
df[1,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2])
df
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3])
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4])
child_name <- names(dimnames(CPT)[1])
child_states <- dimnames(CPT)[[1]]
parent_states_1 <- dimnames(CPT)[[2]]
parent_states_2 <- dimnames(CPT)[[3]]
parent_states_3 <- dimnames(CPT)[[4]]
child_name <- names(dimnames(CPT)[1])
parent_name1 <- names(dimnames(CPT)[2])
parent_name2 <- names(dimnames(CPT)[3])
parent_name3 <- names(dimnames(CPT)[4])
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4])
df
df[1,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df
df[1,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 2)
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 2)
df
df[1,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 2)
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df
df[1,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 1)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 2)
df
CPT
df[,1] <- c(parent_name1,parent_name2,parent_name3,child_states)
df[3,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[1,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df
CPT
CPT %>% as.matrix
replace(NA, CPT %>% as.matrix)
replace(df, NA, CPT %>% as.matrix)
df[is.na(df)] <- CPT %>% as.matrix
df
CPT
df
rownames(df)<- colnames(df) <- c()
df
row.names(df)
row.names(df)<- colnames(df) <- c()
df
row.names(df)<- colnames(df) <- NULL
df
n_dims
for(i in 2: n_dims) { paste('parent_name',i) = names(dimnames(CPT))}
i = 1:4
paste('parent_name',i)
paste('parent_name_',i)
paste0('parent_name_',i)
for(i in 2: n_dims) { paste0('parent_name_',i) = names(dimnames(CPT))}
x <- c(a1 = 1, b1 = 2)
names(x) <- c(newName1, newName2)
names(x) <- c('newName1', 'newName2')
x
for(i in 2: n_dims) { assign(paste0('parent_name',i), names(dimnames(CPT)))}
parent_name1
parent_name2
dims[2]*dims[3]*dims[4]+1
prod(dims[-1])
df
n_dims
## Transform the CPT array to presentable dataframe
transform_CPT <- function(CPT) {
dims <- dim(CPT)
n_dims <- length(dims)
child_states <- dimnames(CPT)[[1]]
child_name <- names(dimnames(CPT)[1])
for(i in 2: n_dims) { assign(paste0('parent_state_',i-1), names(dimnames(CPT)[i]))}
for(i in 2: n_dims) { assign(paste0('parent_name_',i-1), names(dimnames(CPT)[i]))}
matrix_dim <- c(dims[1]+n_dims-1, prod(dims[-1])+1)
df <- data.frame(matrix(NA, nrow = matrix_dim[1], ncol = matrix_dim[2]))
if (n_dims  == 3) {
df[,1] <- c(parent_name1,parent_name2,child_states)
df[2,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[1,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
} else if (n_dims == 4) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,child_states)
df[3,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[1,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
} else if (n_dims == 5) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,parent_name4,child_states)
df[4,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[3,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[2,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[1,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
} else if (n_dims == 6) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,parent_name4,parent_name5,child_states)
df[5,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[4,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[2,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
df[1,-1] <- rep(parent_states_5,prod(dims[-1])/dims[6], along = 1)
}
df[is.na(df)] <- CPT %>% as.matrix
row.names(df)<- colnames(df) <- NULL
}
runApp()
CPT %>% transform_CPT
CPT
transform_CPT(CPT)
dim(CPT)
## Transform the CPT array to presentable dataframe
transform_CPT <- function(CPT) {
dims <- dim(CPT)
n_dims <- length(dims)
child_states <- dimnames(CPT)[[1]]
child_name <- names(dimnames(CPT)[1])
for(i in 2: n_dims) { assign(paste0('parent_state_',i-1), names(dimnames(CPT)[i]))}
for(i in 2: n_dims) { assign(paste0('parent_name_',i-1), names(dimnames(CPT)[i]))}
matrix_dim <- c(dims[1]+n_dims-1, prod(dims[-1])+1)
df <- data.frame(matrix(NA, nrow = matrix_dim[1], ncol = matrix_dim[2]))
if (n_dims  == 3) {
df[,1] <- c(parent_name1,parent_name2,child_states)
df[2,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[1,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
} else if (n_dims == 4) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,child_states)
df[3,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[1,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
} else if (n_dims == 5) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,parent_name4,child_states)
df[4,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[3,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[2,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[1,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
} else if (n_dims == 6) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,parent_name4,parent_name5,child_states)
df[5,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[4,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[2,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
df[1,-1] <- rep(parent_states_5,prod(dims[-1])/dims[6], along = 1)
}
df[is.na(df)] <- CPT %>% as.matrix
row.names(df)<- colnames(df) <- NULL
return(DF)
}
transform_CPT(CPT)
dims <- dim(CPT)
n_dims <- length(dims)
child_states <- dimnames(CPT)[[1]]
child_name <- names(dimnames(CPT)[1])
for(i in 2: n_dims) { assign(paste0('parent_state_',i-1), names(dimnames(CPT)[i]))}
for(i in 2: n_dims) { assign(paste0('parent_name_',i-1), names(dimnames(CPT)[i]))}
matrix_dim <- c(dims[1]+n_dims-1, prod(dims[-1])+1)
df <- data.frame(matrix(NA, nrow = matrix_dim[1], ncol = matrix_dim[2]))
if (n_dims  == 3) {
df[,1] <- c(parent_name1,parent_name2,child_states)
df[2,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[1,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
} else if (n_dims == 4) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,child_states)
df[3,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[1,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
} else if (n_dims == 5) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,parent_name4,child_states)
df[4,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[3,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[2,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[1,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
} else if (n_dims == 6) {
df[,1] <- c(parent_name1,parent_name2,parent_name3,parent_name4,parent_name5,child_states)
df[5,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[4,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[2,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
df[1,-1] <- rep(parent_states_5,prod(dims[-1])/dims[6], along = 1)
}
n_dims
df[,1] <- c(parent_name1,parent_name2,parent_name3,child_states)
df
c(parent_name1,parent_name2,parent_name3,parent_name4,child_states)
parent_name1
parent_name2
parent_name3
parent_name4
c(parent_name_1,parent_name_2,parent_name_3,child_states)
## Transform the CPT array to presentable dataframe
transform_CPT <- function(CPT) {
dims <- dim(CPT)
n_dims <- length(dims)
child_states <- dimnames(CPT)[[1]]
child_name <- names(dimnames(CPT)[1])
for(i in 2: n_dims) { assign(paste0('parent_state_',i-1), names(dimnames(CPT)[i]))}
for(i in 2: n_dims) { assign(paste0('parent_name_',i-1), names(dimnames(CPT)[i]))}
matrix_dim <- c(dims[1]+n_dims-1, prod(dims[-1])+1)
df <- data.frame(matrix(NA, nrow = matrix_dim[1], ncol = matrix_dim[2]))
if (n_dims  == 3) {
df[,1] <- c(parent_name_1,parent_name_2,child_states)
df[2,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[1,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
} else if (n_dims == 4) {
df[,1] <- c(parent_name_1,parent_name_2,parent_name_3,child_states)
df[3,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[1,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
} else if (n_dims == 5) {
df[,1] <- c(parent_name_1,parent_name_2,parent_name_3,parent_name_4,child_states)
df[4,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[3,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[2,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[1,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
} else if (n_dims == 6) {
df[,1] <- c(parent_name_1,parent_name_2,parent_name_3,parent_name_4,parent_name_5,child_states)
df[5,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[4,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[2,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
df[1,-1] <- rep(parent_states_5,prod(dims[-1])/dims[6], along = 1)
}
df[is.na(df)] <- CPT %>% as.matrix
row.names(df)<- colnames(df) <- NULL
return(DF)
}
CPT %>% transform_CPT
## Transform the CPT array to presentable dataframe
transform_CPT <- function(CPT) {
dims <- dim(CPT)
n_dims <- length(dims)
child_states <- dimnames(CPT)[[1]]
child_name <- names(dimnames(CPT)[1])
for(i in 2: n_dims) { assign(paste0('parent_state_',i-1), names(dimnames(CPT)[i]))}
for(i in 2: n_dims) { assign(paste0('parent_name_',i-1), names(dimnames(CPT)[i]))}
matrix_dim <- c(dims[1]+n_dims-1, prod(dims[-1])+1)
df <- data.frame(matrix(NA, nrow = matrix_dim[1], ncol = matrix_dim[2]))
if (n_dims  == 3) {
df[,1] <- c(parent_name_1,parent_name_2,child_states)
df[2,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[1,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
} else if (n_dims == 4) {
df[,1] <- c(parent_name_1,parent_name_2,parent_name_3,child_states)
df[3,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[2,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[1,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
} else if (n_dims == 5) {
df[,1] <- c(parent_name_1,parent_name_2,parent_name_3,parent_name_4,child_states)
df[4,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[3,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[2,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[1,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
} else if (n_dims == 6) {
df[,1] <- c(parent_name_1,parent_name_2,parent_name_3,parent_name_4,parent_name_5,child_states)
df[5,-1] <- rep(parent_states_1,prod(dims[-1])/dims[2], along = 2)
df[4,-1] <- rep(parent_states_2,prod(dims[-1])/dims[3], along = 1)
df[3,-1] <- rep(parent_states_3,prod(dims[-1])/dims[4], along = 1)
df[2,-1] <- rep(parent_states_4,prod(dims[-1])/dims[5], along = 1)
df[1,-1] <- rep(parent_states_5,prod(dims[-1])/dims[6], along = 1)
}
df[is.na(df)] <- CPT %>% as.matrix
row.names(df)<- colnames(df) <- NULL
return(df)
}
CPT %>% transform_CPT
runApp()
CPT <- network[["Impact"]]$CPT
CPT %>% transform_CPT
runApp()
runApp()
shiny::runApp(system.file('multipleData',package='editData'))
install.packages("tidyverse")
shiny::runApp(system.file('multipleData',package='editData'))
runApp()
runApp()
runApp()
runApp()
library(shiny)
library(DT)
dt_output = function(title, id) {
fluidRow(column(
12, h1(paste0('Table ', sub('.*?([0-9]+)$', '\\1', id), ': ', title)),
hr(), DTOutput(id)
))
}
render_dt = function(data, editable = 'cell', server = TRUE, ...) {
renderDT(data, selection = 'none', server = server, editable = editable, ...)
}
shinyApp(
ui = fluidPage(
title = 'Double-click to edit table cells',
dt_output('client-side processing (editable = "cell")', 'x1'),
dt_output('client-side processing (editable = "row")', 'x2'),
dt_output('client-side processing (editable = "column")', 'x3'),
dt_output('client-side processing (editable = "all")', 'x4'),
dt_output('server-side processing (editable = "cell")', 'x5'),
dt_output('server-side processing (editable = "row")', 'x6'),
dt_output('server-side processing (editable = "column")', 'x7'),
dt_output('server-side processing (editable = "all")', 'x8'),
dt_output('server-side processing (no row names)', 'x9'),
dt_output('edit rows but disable certain columns (editable = list(target = "row", disable = list(columns = c(2, 4, 5))))', 'x10')
),
server = function(input, output, session) {
d1 = iris
d1$Date = Sys.time() + seq_len(nrow(d1))
d10 = d9 = d8 = d7 = d6 = d5 = d4 = d3 = d2 = d1
options(DT.options = list(pageLength = 5))
# client-side processing
output$x1 = render_dt(d1, 'cell', FALSE)
output$x2 = render_dt(d2, 'row', FALSE)
output$x3 = render_dt(d3, 'column', FALSE)
output$x4 = render_dt(d4, 'all', FALSE)
observe(str(input$x1_cell_edit))
observe(str(input$x2_cell_edit))
observe(str(input$x3_cell_edit))
observe(str(input$x4_cell_edit))
# server-side processing
output$x5 = render_dt(d5, 'cell')
output$x6 = render_dt(d6, 'row')
output$x7 = render_dt(d7, 'column')
output$x8 = render_dt(d8, 'all')
output$x9 = render_dt(d9, 'cell', rownames = FALSE)
output$x10 = render_dt(d10, list(target = 'row', disable = list(columns = c(2, 4, 5))))
# edit a single cell
proxy5 = dataTableProxy('x5')
observeEvent(input$x5_cell_edit, {
info = input$x5_cell_edit
str(info)  # check what info looks like (a data frame of 3 columns)
d5 <<- editData(d5, info)
replaceData(proxy5, d5, resetPaging = FALSE)  # important
# the above steps can be merged into a single editData() call; see examples below
})
# edit a row
observeEvent(input$x6_cell_edit, {
d6 <<- editData(d6, input$x6_cell_edit, 'x6')
})
# edit a column
observeEvent(input$x7_cell_edit, {
d7 <<- editData(d7, input$x7_cell_edit, 'x7')
})
# edit all cells
observeEvent(input$x8_cell_edit, {
d8 <<- editData(d8, input$x8_cell_edit, 'x8')
})
# when the table doesn't contain row names
observeEvent(input$x9_cell_edit, {
d9 <<- editData(d9, input$x9_cell_edit, 'x9', rownames = FALSE)
})
# edit rows but disable columns 2, 4, 5
observeEvent(input$x10_cell_edit, {
d10 <<- editData(d10, input$x10_cell_edit, 'x10')
})
}
)
version(DT)
install.packages(c("callr", "checkmate", "clipr", "coda", "curl", "devtools", "digest", "dplyr", "DT", "evaluate", "fs", "ggplot2", "git2r", "hms", "knitr", "markdown", "mime", "mvtnorm", "numDeriv", "openssl", "parsedate", "pillar", "processx", "rcmdcheck", "Rcpp", "RcppArmadillo", "remotes", "RJSONIO", "rlang", "rsconnect", "shinyAce", "shinytest", "testthat", "tibble", "usethis", "visNetwork", "xfun", "XML", "zip"))
library("DT", lib.loc="~/R/win-library/3.5")
install.packages('DT')
install.packages("DT")
